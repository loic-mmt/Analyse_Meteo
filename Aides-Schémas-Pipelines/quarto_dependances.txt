# Quarto, Python & Julia – Project Interaction Recap

## 1. What Quarto Is in This Project

Quarto is **not the computation engine**. It is the **orchestrator and UI layer** that:

* Renders static reports (`spatial_masking.qmd`)
* Hosts the interactive dashboard (`dashboard.qmd`)
* Executes **Python and Julia code in isolated kernels**
* Manages the final outputs (HTML, dashboard, plots)

Quarto does **not replace DVC, Python, or Julia**. It only connects them.

---

## 2. Core Project Dependencies

### Python Dependencies (`requirements.txt`)

Used for:

* Data download
* NetCDF processing
* Dashboard backend

Main libraries:

* `xarray`
* `netCDF4`
* `dask`
* `cdsapi`
* `shiny`
* `plotly` or `matplotlib`

### Julia Dependencies (`Project.toml`)

Used for:

* Spatial geometry
* Mask computation

Main libraries:

* `Shapefile`
* `PolygonOps`
* `NetCDF`
* `NPZ`
* `DataFrames`

### Quarto Dependencies

Quarto itself depends on:

* **Python kernel (Jupyter)**
* **Julia kernel**
* **Node.js (for dashboard & JS components)**
* **Shiny for Python**

---

## 3. How a Quarto File Is Structured

A `.qmd` file always has:

### 1. YAML Header (configuration)

Defines:

* Output format (html, dashboard)
* Server mode (shiny)
* Which engines are used

Example:

```yaml
---
title: "Climate Dashboard"
format: dashboard
server: shiny
---
```

### 2. Code Cells (Python or Julia)

Each cell explicitly selects its language:

```python
#| echo: false
import xarray as xr
```

```julia
#| echo: false
using NetCDF, Shapefile
```

### 3. UI + Logic (for dashboard)

* UI inputs (sliders, selects)
* Reactive Python backend (Shiny)

---

## 4. Python ↔ Julia Interaction Problem

⚠️ **Python and Julia do NOT share memory inside Quarto.**
They run in **separate kernels**.

So this is **NOT possible**:

* Create object in Julia → reuse directly in Python
* Pass arrays directly between languages in RAM

---

## 5. The Correct Way to Connect Python & Julia

✅ The only reliable method is **file-based communication**:

### The Standard Workflow

1. **Julia computes masks**

   * Input: NetCDF + Shapefiles
   * Output: `data/masks/mask_region.nc`

2. **Python loads masks**

   * Reads the `.nc` masks
   * Applies them to the climate dataset

This is exactly what your pipeline already does:

| Step                | Language | I/O                     |
| ------------------- | -------- | ----------------------- |
| Download ERA5       | Python   | raw `.nc`               |
| Monthly aggregation | Python   | processed `.nc`         |
| Spatial masks       | Julia    | mask `.nc`              |
| Dashboard           | Python   | reads processed + masks |

---

## 6. Temporary Files Strategy

If tight coupling is required inside a Quarto report:

### Julia → Temp File

```julia
using NPZ
npzwrite("temp_mask.npz", mask_array)
```

### Python → Read Temp File

```python
import numpy as np
mask = np.load("temp_mask.npz")["arr_0"]
```

⚠️ This is slower than NetCDF but useful for debugging or experiments.

---

## 7. Who Does What (Final Architecture)

| Component        | Role                                      |
| ---------------- | ----------------------------------------- |
| **DVC**          | Pipeline orchestration & reproducibility  |
| **Python**       | API, NetCDF processing, dashboard backend |
| **Julia**        | Heavy geometry & spatial precision        |
| **Quarto**       | Report rendering + interactive UI         |
| **NetCDF Files** | Communication bridge                      |

---

## 8. Key Rule (Very Important)

> **Quarto does not replace the data pipeline.
> It only visualizes the final products generated by Python & Julia.**

All heavy computation must stay in:

* `src/aggregate.py`
* `src/make_masks.jl`

The `.qmd` files should only:

* Load
* Filter
* Visualize


Julia → Python temp-file example specifically for masks**

Ce qu'il faut installer :
nstallation des dépendances pour le projet my-climate-project
1️⃣ Python

Créer un environnement virtuel (recommandé) :

cd my-climate-project
python -m venv .venv


Activer l’environnement :

Windows (PowerShell) :

.venv\Scripts\Activate.ps1


Windows (cmd) :

.venv\Scripts\activate.bat


Installer les bibliothèques Python :

pip install --upgrade pip
pip install -r requirements.txt


Cela installe toutes les bibliothèques nécessaires : xarray, netCDF4, pandas, numpy, shiny, etc.

2️⃣ Julia

Installer Julia depuis https://julialang.org/download/
.

Dans Julia, activer l’environnement du projet et installer les packages :

using Pkg
Pkg.activate(".")
Pkg.instantiate()


Cela installe tous les packages listés dans Project.toml : Shapefile, PolygonOps, NPZ, etc.

3️⃣ Quarto

Installer Quarto depuis https://quarto.org/download/
.

Vérifier l’installation :

quarto --version


Assurer que les kernels Python et Julia sont disponibles pour Quarto.

Pour Julia :

using IJulia

4️⃣ DVC (Data Version Control)

Installer DVC :

pip install dvc


Initialiser DVC dans le projet :

dvc init


Ajouter les dossiers de données à suivre :

dvc add data/raw
dvc add data/processed


Committer les fichiers .dvc et dvc.lock dans Git.

Les fichiers temporaires dans data/temp/ ne doivent pas être suivis par DVC. Ils servent uniquement à échanger des données Python ↔ Julia.

5️⃣ Fichiers temporaires

Ils permettent à Python et Julia d’échanger des données dans Quarto.

Formats recommandés : CSV, NetCDF, Parquet, HDF5.

Exemple :

Python écrit : df.to_csv("data/temp/temp.csv", index=False)

Julia lit : df = CSV.read("data/temp/temp.csv", DataFrame)

Cette méthode est stable, reproductible et indépendante du langage.