# Quarto, Python & Julia – Project Interaction Recap

## 1. What Quarto Is in This Project

Quarto is **not the computation engine**. It is the **orchestrator and UI layer** that:

* Renders static reports (`spatial_masking.qmd`)
* Hosts the interactive dashboard (`dashboard.qmd`)
* Executes **Python and Julia code in isolated kernels**
* Manages the final outputs (HTML, dashboard, plots)

Quarto does **not replace DVC, Python, or Julia**. It only connects them.

---

## 2. Core Project Dependencies

### Python Dependencies (`requirements.txt`)

Used for:

* Data download
* NetCDF processing
* Dashboard backend

Main libraries:

* `xarray`
* `netCDF4`
* `dask`
* `cdsapi`
* `shiny`
* `plotly` or `matplotlib`

### Julia Dependencies (`Project.toml`)

Used for:

* Spatial geometry
* Mask computation

Main libraries:

* `Shapefile`
* `PolygonOps`
* `NetCDF`
* `NPZ`
* `DataFrames`

### Quarto Dependencies

Quarto itself depends on:

* **Python kernel (Jupyter)**
* **Julia kernel**
* **Node.js (for dashboard & JS components)**
* **Shiny for Python**

---

## 3. How a Quarto File Is Structured

A `.qmd` file always has:

### 1. YAML Header (configuration)

Defines:

* Output format (html, dashboard)
* Server mode (shiny)
* Which engines are used

Example:

```yaml
---
title: "Climate Dashboard"
format: dashboard
server: shiny
---
```

### 2. Code Cells (Python or Julia)

Each cell explicitly selects its language:

```python
#| echo: false
import xarray as xr
```

```julia
#| echo: false
using NetCDF, Shapefile
```

### 3. UI + Logic (for dashboard)

* UI inputs (sliders, selects)
* Reactive Python backend (Shiny)

---

## 4. Python ↔ Julia Interaction Problem

⚠️ **Python and Julia do NOT share memory inside Quarto.**
They run in **separate kernels**.

So this is **NOT possible**:

* Create object in Julia → reuse directly in Python
* Pass arrays directly between languages in RAM

---

## 5. The Correct Way to Connect Python & Julia

✅ The only reliable method is **file-based communication**:

### The Standard Workflow

1. **Julia computes masks**

   * Input: NetCDF + Shapefiles
   * Output: `data/masks/mask_region.nc`

2. **Python loads masks**

   * Reads the `.nc` masks
   * Applies them to the climate dataset

This is exactly what your pipeline already does:

| Step                | Language | I/O                     |
| ------------------- | -------- | ----------------------- |
| Download ERA5       | Python   | raw `.nc`               |
| Monthly aggregation | Python   | processed `.nc`         |
| Spatial masks       | Julia    | mask `.nc`              |
| Dashboard           | Python   | reads processed + masks |

---

## 6. Temporary Files Strategy

If tight coupling is required inside a Quarto report:

### Julia → Temp File

```julia
using NPZ
npzwrite("temp_mask.npz", mask_array)
```

### Python → Read Temp File

```python
import numpy as np
mask = np.load("temp_mask.npz")["arr_0"]
```

⚠️ This is slower than NetCDF but useful for debugging or experiments.

---

## 7. Who Does What (Final Architecture)

| Component        | Role                                      |
| ---------------- | ----------------------------------------- |
| **DVC**          | Pipeline orchestration & reproducibility  |
| **Python**       | API, NetCDF processing, dashboard backend |
| **Julia**        | Heavy geometry & spatial precision        |
| **Quarto**       | Report rendering + interactive UI         |
| **NetCDF Files** | Communication bridge                      |

---

## 8. Key Rule (Very Important)

> **Quarto does not replace the data pipeline.
> It only visualizes the final products generated by Python & Julia.**

All heavy computation must stay in:

* `src/aggregate.py`
* `src/make_masks.jl`

The `.qmd` files should only:

* Load
* Filter
* Visualize


lia → Python temp-file example specifically for masks**
